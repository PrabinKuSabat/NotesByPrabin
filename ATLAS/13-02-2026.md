# Questions

1. What's a hypervisor mode and how it's different from the kernel or supervisor mode? And how all of this is different from the machine mode?  
	ℹ️ OrangePi RV2 doesn't support hypervisor mode.
2. How efficient is Bound Multiprocessing? What scenarios can be helped by Processor Affinity and Pinning?

# Sequential Latency Test
## Type 1
```bash
ioctl(fd, PERF_EVENT_IOC_RESET, 0);
ioctl(fd, PERF_EVENT_IOC_ENABLE, 0);

volatile uint64_t tmp = 0;

for (uint64_t p = 0; p < PASSES; p++) {
		for (size_t i = 0; i < len; i += 8) {
				tmp = array[i+0];
				tmp = array[i+1];
				tmp = array[i+2];
				tmp = array[i+3];
				tmp = array[i+4];
				tmp = array[i+5];
				tmp = array[i+6];
				tmp = array[i+7];
		}
}

ioctl(fd, PERF_EVENT_IOC_DISABLE, 0);

uint64_t cycles = 0;
read(fd, &cycles, sizeof(cycles));
```
Here the values are just stored in `tmp`. But it's not used anywhere. So there won't be write-back.
> [!question] write-back?
> Is it correct to say that there won't be any writeback?

```bash
# Results
Working set: 32768 bytes
Total loads: 409600000
Total cycles: 478906210
Cycles per load: 1.169205
Loads per cycle: 0.855282

# -----------------------------
Working set: 16384 bytes
Total loads: 204800000
Total cycles: 232457513
Cycles per load: 1.135046
Loads per cycle: 0.881021
```

## Type 2
```bash
ioctl(fd, PERF_EVENT_IOC_RESET, 0);
    ioctl(fd, PERF_EVENT_IOC_ENABLE, 0);

    for (size_t j = 0; j < iters; j++) {

        size_t i = 0;

        /* 8 independent accumulation chains */
        for (; i + 7 < n; i += 8) {
            s0 += arr[i];
            s1 += arr[i+1];
            s2 += arr[i+2];
            s3 += arr[i+3];
            s4 += arr[i+4];
            s5 += arr[i+5];
            s6 += arr[i+6];
            s7 += arr[i+7];
        }

        /* Handle remainder */
        for (; i < n; i++) {
            s0 += arr[i];
        }
    }

//    uint64_t end = rdcycle();
    ioctl(fd, PERF_EVENT_IOC_DISABLE, 0);
```
Now a similar setup with `+=` 