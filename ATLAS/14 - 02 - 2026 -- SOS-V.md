# Initial Questions

1. Major planning scheduler and performance Validation.
2. Asymmetric Scheduler
	1. AI codes -> AIQC
	2. QS codes -> QC
	3. Normal Programs -> AIQC & QC
3. Only changing the kernel may not work.
	1. May be we will have to modify bootloader?
	2. Opensbi has to be changed to give some of the CSR accesses.
4. Will we have to build everything from the start?
	- Or can the opensbi and U-Boot be used ?
5. What are the different performance validations one can do for a new system, when there are not any architectural details?
6. Can I write a bootloader which works on any developer board?
7. Major problem is each vendor has OS for their boards but they are independently maintained and not updated after a specific time. Can we have a OS which can boot anywhere?
	- Is this possible using AI or any other method?
	- And why each vendor has a modified Linux distr. for its boards?

# Initial Steps for writing a User-level OS

- User level application : Multi - threaded but we won't use posix threads or any library for creating multi threded application.
	- Multi-threaded : Multiple processor can come into the same user process and execute different routines, obviously at the same time.
- We will in the application create a launching pad routine for each processor to come and grab a data area or a data structure to own inside the user application. Each processor will store their own registers privately. That means the registers which are there in this data structures. That means other processor will not go and touch another processors data structures. Data-strct name : PPDA (Per Processor Data Area).
	- Similarly we will create a process table structure. Each process table entry will point to a routine in the application to execute. These routines could be imagined to be separate application. Example : Linked-List chasing a Linked-List or Inserting a node into a Linked-List or deleting one. Obviously each processor have to execute each processes or application carefully. If the data-area for the Linked-List is same. In other words the Linked-List is exactly the same which is being worked by different processor where one is chasing a Linked-List another is inserting and third one is deleting. In these cases each processor will have to take a lock on the whole Linked-List before executing the process in the process table. There are lot of ways we can run these applications through the process table. Today we are going to discuss how to setup a process table how to setup a PPDA how to setup a application and run all of these application on different processors. In the beginning we will make these Linked-List independent of each other. In other words we will have separate data areas for each of these Linked-List. This means we need not take locks in the first stage of the user-level OS.
- First Step is to write a launching pad routine where all the processors from linux will come in.
- There will be only one application for linux to execute. The linux will come into main.c of the student application. main.c will go to a routine called processor launching pad.
  - In this routine the processor will inquire is process-id or hart-id.
- We will have to do a syscl to read mhartid CSR.

  > [!abstract] Check it out

> 1. POSIX Shared Memory (Recommended) 
> 
> This is the modern, standard approach in Linux. It uses a "name" (like a file path) to identify the memory segment.
> - **Creation:** Use `shm_open()` to create or open a shared memory object.
> - **Sizing:** Use `ftruncate()` to set the size of the segment.
> - **Mapping:** Use `mmap()` to map the segment into your process's address space.
> - **Cleanup:** Use `shm_unlink()` to remove the object from the system once all processes are finished.

Do taskset for same program for all 8 cores and print the core no.  
aa.c create a launching pad. Put on each of the hart-id and hart-id will print into the shared memory.
[[User-Level OS Implementation - Idea Board]]